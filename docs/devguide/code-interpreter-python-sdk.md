# Using CodeInterpreter with Python SDK

The AgentCube Python SDK (`agentcube`) provides a high-level wrapper for interacting with CodeInterpreter. It handles session lifecycle management, authentication, and secure communication (RSA encryption), allowing you to focus on executing code and managing files.

This guide describes how to install, configure, and use the SDK to build automation agents.

## Prerequisites

Before you begin, ensure your environment meets the following requirements:

* **Python**: Version 3.8 or later.
* **Network Access**: Access to the Workload Manager (Control Plane) and Router (Data Plane).
* **Package Installation**:

    ```bash
    pip install agentcube-sdk
    ```

## 1. Initialize the Client

The `CodeInterpreterClient` is the main entry point. You can initialize it directly or use it as a context manager (recommended) to ensure sessions are automatically cleaned up.

### Configuration Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `name` | `str` | `"simple-codeinterpreter"` | CodeInterpreter CRD template name |
| `namespace` | `str` | `"default"` | Kubernetes namespace |
| `ttl` | `int` | `3600` | Session time-to-live (seconds) |
| `workload_manager_url` | `str` | `None` | Control Plane URL (falls back to env `WORKLOAD_MANAGER_URL`) |
| `router_url` | `str` | `None` | Data Plane Router URL (falls back to env `ROUTER_URL`) |
| `auth_token` | `str` | `None` | Auth token (falls back to K8s SA token) |
| `session_id` | `str` | `None` | Reuse existing session instead of creating new |
| `verbose` | `bool` | `False` | Enable debug logging |

### Environment Variables

| Variable | Description |
|----------|-------------|
| `WORKLOAD_MANAGER_URL` | Control Plane URL (required if not passed as argument) |
| `ROUTER_URL` | Data Plane Router URL (required if not passed as argument) |

### Example: Basic Initialization

```python
from agentcube import CodeInterpreterClient

# Initialize and start session
client = CodeInterpreterClient(
    name="my-agent",
    ttl=3600,
    verbose=True
)
```

## 2. Execute Commands and Code

The SDK provides distinct methods for running shell commands and executing code blocks.

### Run Shell Commands

Use `execute_command` to run system operations on the remote agent.

```python
# Check the current user and directory
output = client.execute_command("whoami && pwd")
print(output)
```

### Run Code

Use `run_code` to execute scripts. Supported languages: `"python"` (or `"py"`, `"python3"`) and `"bash"` (or `"sh"`).

```python
# Python example
script = """
import math
print(f"The square root of 16 is {math.sqrt(16)}")
"""
result = client.run_code(language="python", code=script)
print(result)

# Bash example
result = client.run_code(language="bash", code="echo 'Hello from Bash!'")
print(result)
```

## 3. File Management

You can transfer files between your local environment and the remote CodeInterpreter instance.

### Upload Files

Use `upload_file` to send local files to the sandbox.

```python
# Upload a data file for processing
client.upload_file(
    local_path="./local_data.csv", 
    remote_path="/tmp/data.csv"
)
```

### Download Files

Use `download_file` to retrieve results generated by your scripts.

```python
# Download the processed report
client.download_file(
    remote_path="/tmp/report.json", 
    local_path="./final_report.json"
)
```

### Write Content Directly

Use `write_file` to create text files on the remote server without a local source file.

```python
client.write_file(
    content="print('Hello World')", 
    remote_path="/tmp/hello.py"
)
```

### List Files

Use `list_files` to list files and directories in a specified path.

```python
files = client.list_files("/tmp")
for f in files:
    print(f"{f['name']} - {f['size']} bytes")
```

## 4. Best Practices: Using Context Managers

To ensure that remote resources are terminated and local connections are closed properly, it is recommended to use the `with` statement.

**Complete Example:**

```python
from agentcube import CodeInterpreterClient

def process_data_task():
    # Session automatically starts here
    with CodeInterpreterClient(ttl=600) as sandbox:
        print(f"Session ID: {sandbox.session_id}")

        # 1. Create a Python script remotely
        script_content = """
import json
data = {"status": "processed", "value": 42}
with open('/tmp/result.json', 'w') as f:
    json.dump(data, f)
print("Data processed.")
        """
        
        # 2. Execute the script
        print("Executing remote script...")
        logs = sandbox.run_code("python", script_content)
        print(f"Remote Logs: {logs}")

        # 3. Download the result
        sandbox.download_file("/tmp/result.json", "./result.json")
        print("File downloaded to ./result.json")

    # Session automatically stops (deleted) here
```

## 5. Manual Lifecycle Management

If you cannot use a context manager (e.g., in a persistent web server), you must manually call `stop()` to free resources.

```python
client = CodeInterpreterClient(ttl=3600)

try:
    client.execute_command("echo 'Running long task...'")
finally:
    # Critical: Delete the remote Pod and close connections
    client.stop()
```

## 6. Session Reuse

You can reuse an existing session by passing its `session_id` to a new client. This is useful for multi-step workflows.

> **Important**: Session reuse preserves **file system state only**. Each `run_code` call spawns a new process, so **Python variables do NOT persist** across calls.

```python
# Step 1: Create session and save a file
client1 = CodeInterpreterClient()
session_id = client1.session_id
client1.write_file("42", "/tmp/value.txt")
# Don't call stop() - let session persist

# Step 2: Reuse session with new client
client2 = CodeInterpreterClient(session_id=session_id)
# File persists across clients
client2.run_code("python", "print(open('/tmp/value.txt').read())")
client2.stop()  # Cleanup when done
```
